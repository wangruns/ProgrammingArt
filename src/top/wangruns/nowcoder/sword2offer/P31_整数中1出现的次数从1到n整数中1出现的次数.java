package top.wangruns.nowcoder.sword2offer;

/**
 * 
 * 题目描述
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
 *
 * 分析
1到n的数字变化，可以看做是齿轮的转动，从个位开始转动(1,2,3,...,9,0),然后十位开始转动(1,2,3,...9,0),然后百位...
比如n=234，那么从1到234的数字变化中一共出现过多少个1呢？即在各个位上的齿轮1出现的次数。
0 0 1
0 0 2
...
0 0 9
0 1 0
可以看到个位位置转一圈(个位数字从0-9变化)，1会出现一次，然而个位位置一共需要转多少圈取决于个位左边的位数，如这里的23
表示个数的齿轮一共已经转了23圈，当然啦，24的圈还没有转完对吧？个位的数字只转到4呢毕竟。那么这已经转完的23圈，显然个位
位置会出现23次1，然后加上第24的圈为4，表示1已经转过了，所以个位上1出现的次数为23+1=24

而对于十位位置来说也是一样的，十位位置上的数字从也是从0到9变化，而十位上的数字每转1圈，1也会在该位置上出现一次，
那么十位位置一共转了多少圈呢？同样地，还是取决与该位左边的树，如这里的2，表示十位位置上的齿轮一共已经转动了2圈了，当然啦，
第3的圈还没有转完对吧？十位上的数字为3呢毕竟，但是1已经出现过了对吧? 和个位的不同之处在于，在十位上的数字齿轮转动一下，
是需要个位上的齿轮转动一圈(10下)的。所以在十位上1出现的次数为(2+1)*10=30

同理我们知道百位上的数字齿轮一圈都没有转到，只转动了两次对吧？而这两次中已经出现了1，所以在百位位上出现的1的次数为1*100=100

故1-234中，1总的出现次数为24 + 30 + 100 = 154
一般地
   left  cur  right
n = 12    3    41   
       base=100
若cur为0，则在cur位置上1出现的次数为left*base
若cur为1,则在cur位置上1出现的次数为left*base + right + 1
若cur大于1,则在cur位置上1出现的次数为(left+1)*base

Reference:
https://blog.csdn.net/yi_afly/article/details/52012593
 */
public class P31_整数中1出现的次数从1到n整数中1出现的次数 {
	
	//暴力方法
	public int NumberOf1Between1AndN_Solution1(int n) {
	    int cnt=0;
	    for(int i=1;i<=n;i++) {
	    	for(int j=1;j<=i;j*=10) {
	    		//判断十位百位...是不是1
	    		int temp=i/(10*j);
	    		cnt+=temp%10==1?1:0;
	    	}
	    	//判断个位是不是1
	    	cnt+=i%10==1?1:0;
	    }
	    return cnt;
    }
	
	//分析归纳齿轮转动法
	public int NumberOf1Between1AndN_Solution2(int n) {
		int cnt=0;
		for(int base=1;base<=n;base*=10) {
			int cur=(n/base)%10;
			int left=(n/base)/10;
			int right=n%base;
			if(cur==0) cnt+=left*base;
			else if(cur==1) cnt+=left*base+right+1;
			else cnt+=(left+1)*base;
		}
		return cnt;
	}
	
}
